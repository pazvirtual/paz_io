#ifndef PAZ_IO
#define PAZ_IO

#include <iostream>
#include <vector>
#include <unordered_map>
#include <array>
#include <cstdint>

namespace paz
{
    template<typename T>
    using require_iterable = std::enable_if_t<std::is_same<decltype(std::begin(
        std::declval<const T&>())), decltype(std::end(std::declval<const
        T&>()))>::value>;

    class Bytes : public std::vector<unsigned char>
    {
        using std::vector<unsigned char>::vector;

    public:
        Bytes(const char* str);
        Bytes(const std::string& str);
        std::string str() const;
    };

    class Archive
    {
        std::unordered_map<std::string, Bytes> _blocks;

    public:
        Archive() = default;
        Archive(const std::string& path);
        Archive(const Bytes& src);
        void add(const std::string& name, const Bytes& data);
        Bytes get(const std::string& name) const;
        void load(const std::string& path);
        void write(const std::string& path) const;
        void clear();
    };

#ifndef PAZ_GRAPHICS
    template<typename T, typename U>
    using require_same = std::enable_if_t<std::is_same<T, U>::value>;

    template<typename T, typename U>
    using require_different = std::enable_if_t<!std::is_same<T, U>::value>;

    template<typename T, int NumChannels>
    class Image : public std::vector<T>
    {
        int _rows = 0;

    public:
        Image() = default;
        Image(int width, int height) : std::vector<T>(width*height*NumChannels),
            _rows(height) {}
        Image(const T* data, int width, int height) : std::vector<T>(data, data
            + width*height*NumChannels), _rows(height) {}
        Image(const std::vector<T>& data, int width, int height) : std::vector<
            T>(data), _rows(height)
        {
            if(data.size() != static_cast<std::size_t>(width*height*
                NumChannels))
            {
                throw std::runtime_error("Image dimensions do not match.");
            }
        }
        template<typename U, require_iterable<U>* = nullptr>
        Image(const U& data, int width, int height) : std::vector<T>(std::begin(
            data), std::end(data)), _rows(height)
        {
            if(data.size() != static_cast<std::size_t>(width*height*
                NumChannels))
            {
                throw std::runtime_error("Image dimensions do not match.");
            }
        }
        template<typename U, require_different<T, U>* = nullptr>
        explicit Image(const Image<U, NumChannels>& img) : std::vector<T>(img.
            begin(), img.end()), _rows(img.height()) {}

        int width() const
        {
            return _rows ? std::vector<T>::size()/NumChannels/_rows : 0;
        }

        int height() const
        {
            return _rows;
        }
    };
#endif

    std::array<std::string, 3> split_path(const std::string& path);

    Image<std::uint8_t, 1> parse_pbm(const Bytes& content);

    void write_bmp(const std::string& path, const Image<std::uint8_t, 3>& img);

    // Positions and normals are padded for graphics compatibility ([vx, vy, vz,
    // 1] and [nx, ny, nz, 0]) and materials are one-indexed (0: unassigned, 1:
    // `materialNames[0]`, etc.).
    void parse_obj(const Bytes& content, std::vector<std::string>& names, std::
        vector<std::vector<float>>& positions, std::vector<std::vector<float>>&
        uvs, std::vector<std::vector<float>>& normals, std::vector<std::vector<
        unsigned int>>& materials, std::vector<std::string>& materialNames,
        std::vector<std::string>& materialLibs);
    void parse_obj(const Bytes& content, std::vector<std::string>& names, std::
        vector<std::vector<float>>& positions, std::vector<std::vector<float>>&
        uvs, std::vector<std::vector<float>>& normals, std::vector<std::vector<
        unsigned int>>& materials, std::vector<std::string>& materialNames,
        std::vector<std::string>& materialLibs, std::vector<std::vector<unsigned
        int>>& indices);

    Bytes compress(const Bytes& src);
    Bytes uncompress(const Bytes& src);

    Bytes load_file(const std::string& path);

    void remove(const std::string& path);
}

#endif
